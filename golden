# golden.py
import os, requests, numpy as np, pandas as pd, yfinance as yf, jpholiday
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo

TZ = ZoneInfo("Asia/Tokyo")

# ===== 日経225ティッカー =====
nikkei225_tickers = [ '4151.T','4502.T','4503.T','4506.T','4507.T','4519.T','4523.T','4568.T','4578.T','6479.T','6501.T','6503.T','6504.T','6506.T','6526.T','6594.T','6645.T','6674.T','6701.T','6702.T','6723.T','6724.T','6752.T','6753.T','6758.T','6762.T','6770.T','6841.T','6857.T','6861.T','6902.T','6920.T','6952.T','6954.T','6971.T','6976.T','6981.T','7735.T','7751.T','7752.T','8035.T','7201.T','7202.T','7203.T','7205.T','7211.T','7261.T','7267.T','7269.T','7270.T','7272.T','4543.T','4902.T','6146.T','7731.T','7733.T','7741.T','7762.T','9432.T','9433.T','9434.T','9613.T','9984.T','5831.T','7186.T','8304.T','8306.T','8308.T','8309.T','8316.T','8331.T','8354.T','8411.T','8253.T','8591.T','8697.T','8601.T','8604.T','8630.T','8725.T','8750.T','8766.T','8795.T','1332.T','2002.T','2269.T','2282.T','2501.T','2502.T','2503.T','2801.T','2802.T','2871.T','2914.T','3086.T','3092.T','3099.T','3382.T','7453.T','8233.T','8252.T','8267.T','9843.T','9983.T','2413.T','2432.T','3659.T','4307.T','4324.T','4385.T','4661.T','4689.T','4704.T','4751.T','4755.T','6098.T','6178.T','7974.T','9602.T','9735.T','9766.T','1605.T','3401.T','3402.T','3861.T','3405.T','3407.T','4004.T','4005.T','4021.T','4042.T','4043.T','4061.T','4063.T','4183.T','4188.T','4208.T','4452.T','4901.T','4911.T','6988.T','5019.T','5020.T','5101.T','5108.T','5201.T','5214.T','5233.T','5301.T','5332.T','5333.T','5401.T','5406.T','5411.T','3436.T','5706.T','5711.T','5713.T','5714.T','5801.T','5802.T','5803.T','2768.T','8001.T','8002.T','8015.T','8031.T','8053.T','8058.T','1721.T','1801.T','1802.T','1803.T','1808.T','1812.T','1925.T','1928.T','1963.T','5631.T','6103.T','6113.T','6273.T','6301.T','6302.T','6305.T','6326.T','6361.T','6367.T','6471.T','6472.T','6473.T','7004.T','7011.T','7013.T','7012.T','7832.T','7911.T','7912.T','7951.T','3289.T','8801.T','8802.T','8804.T','8830.T','9001.T','9005.T','9007.T','9008.T','9009.T','9020.T','9021.T','9022.T','9064.T','9147.T','9101.T','9104.T','9107.T','9201.T','9202.T','9301.T','9501.T','9502.T','9503.T','9531.T','9532.T' ]

# 短縮名（必要分だけ。なければ空でOK）
ticker_name_map = {"7203.T":"トヨタ","6758.T":"ソニーG","8035.T":"東エレク","7735.T":"スクリン"}

# ===== LINE送信 =====
LINE_CHANNEL_ACCESS_TOKEN = os.environ.get("LINE_CHANNEL_ACCESS_TOKEN", "")
LINE_USER_ID = os.environ.get("LINE_USER_ID", "")

def line_send(text: str, to_user_id: str | None = LINE_USER_ID):
    assert LINE_CHANNEL_ACCESS_TOKEN, "LINE_CHANNEL_ACCESS_TOKEN is missing"
    headers = {"Authorization": f"Bearer {LINE_CHANNEL_ACCESS_TOKEN}", "Content-Type": "application/json"}
    if to_user_id:
        url = "https://api.line.me/v2/bot/message/push"
        payload = {"to": to_user_id, "messages": [{"type": "text", "text": text}]}
    else:
        url = "https://api.line.me/v2/bot/message/broadcast"
        payload = {"messages": [{"type": "text", "text": text}]}
    r = requests.post(url, headers=headers, json=payload, timeout=20)
    if r.status_code >= 300:
        raise RuntimeError(f"LINE send failed: {r.status_code} {r.text}")

def send_long_text(text: str, chunk=900):
    for i in range(0, len(text), chunk):
        line_send(text[i:i+chunk])

# ===== 共通：データ取得 =====
def fetch_market_data(tickers, lookback_days=300):
    end_dt = datetime.now(tz=TZ).date() + timedelta(days=1)
    start_dt = end_dt - timedelta(days=lookback_days)
    data = yf.download(
        tickers, start=start_dt.isoformat(), end=end_dt.isoformat(),
        interval="1d", auto_adjust=False, progress=False, group_by="column",
    )
    return data["Close"], data.get("Volume")

def sma(s, w): return s.rolling(window=w, min_periods=1).mean()

# ===== 検出ロジック：ゴールデンクロス =====
def detect_golden_cross(close: pd.DataFrame, vol: pd.DataFrame | None,
                        short=50, long=200, within_days=3,
                        min_price=100, vol_ratio=1.0):
    """
    条件（例）:
      - 直近 within_days 日のどこかで SMA(short) が SMA(long) を下→上にクロス
      - 最新終値が両方のSMAより上
      - オプション: 出来高が直近20日平均の vol_ratio 倍以上（volがあれば）
      - 最低株価フィルタ（整数）
    """
    out = []
    sma_s = sma(close, short)
    sma_l = sma(close, long)
    vol_ok = None
    if vol is not None:
        v20 = vol.rolling(20, min_periods=1).mean()
        vol_ok = (vol.iloc[-1] >= v20.iloc[-1] * vol_ratio)

    for t in close.columns:
        s = close[t].dropna()
        if len(s) < long + within_days + 5:  # データ不足
            continue

        ss = sma_s[t].reindex(s.index)
        ll = sma_l[t].reindex(s.index)

        # 直近区間
        ss_w = ss.iloc[-(within_days+1):]
        ll_w = ll.iloc[-(within_days+1):]

        # クロス判定（符号変化：前日まで ss<ll、翌日 ss>=ll）
        cross = ((ss_w.shift(1) < ll_w.shift(1)) & (ss_w >= ll_w)).any()

        latest = float(s.iloc[-1])
        conds = [
            cross,
            latest >= float(ss.iloc[-1]),
            latest >= float(ll.iloc[-1]),
            latest >= min_price,
        ]
        if vol_ok is not None:
            conds.append(bool(vol_ok.get(t, True)))

        if all(conds):
            name = ticker_name_map.get(t, "")
            latest_ss = float(ss.iloc[-1]); latest_ll = float(ll.iloc[-1])
            gap_pct = (latest_ss/latest_ll - 1) * 100.0 if latest_ll else np.nan
            out.append({
                "Ticker": t,
                "Name": name,
                "Latest_Close": round(latest,2),
                "SMA_Short": round(latest_ss,2),
                "SMA_Long": round(latest_ll,2),
                "S_S_vs_L_L_%": round(gap_pct,2),
            })

    if not out: return pd.DataFrame()
    return pd.DataFrame(out).sort_values(["S_S_vs_L_L_%","Latest_Close"], ascending=[False, False]).reset_index(index=False)

# ===== 通知 =====
def notify(df: pd.DataFrame, top_n=15):
    if df is None or df.empty:
        line_send("【GCスクリーニング】該当なし"); return

    def fnum(x):
        try: return f"{float(x):,.0f}"
        except: return "-"
    def fpct(x):
        try: return f"{float(x):.1f}%"
        except: return "-"

    header = (
        f"📈【ゴールデンクロス】{datetime.now(TZ).strftime('%m/%d %H:%M')}\n"
        f"抽出: {len(df)} 銘柄（上位{top_n}を表示）\n"
        f"条件: SMA50↗SMA200 / 終値が両SMA上 / (出来高基準:任意)\n"
        f"——————————————\n"
    )
    send_long_text(header)

    cards = []
    for _, r in df.head(top_n).iterrows():
        t = r["Ticker"]; name = r.get("Name","")
        c = r["Latest_Close"]; ss = r["SMA_Short"]; ll = r["SMA_Long"]; gap = r["S_S_vs_L_L_%"]
        line1 = f"{t} {name}".rstrip()
        line2 = f"終値 {fnum(c)}   短期 {fnum(ss)} / 長期 {fnum(ll)}"
        line3 = f"短長乖離 {fpct(gap)}"
        cards.append("\n".join([line1, line2, line3]))

    for i in range(0, len(cards), 5):
        send_long_text(("\n— — — — —\n").join(cards[i:i+5]))

# ===== 取引日/時間（JST） =====
def is_trading_day_jst(dt: datetime):
    if dt.weekday() >= 5: return False
    if jpholiday.is_holiday(dt.date()): return False
    return True
def is_trading_time_jst(dt: datetime):
    h, m = dt.hour, dt.minute
    return (h > 9 or (h == 9 and m >= 0)) and (h < 15 or (h == 15 and m <= 30))

def main():
    now = datetime.now(TZ)
    force = os.getenv("FORCE_RUN") == "1"
    if not force:
        if not is_trading_day_jst(now) or not is_trading_time_jst(now):
            print(f"[SKIP] {now} 非取引時間"); return

    close, vol = fetch_market_data(nikkei225_tickers, lookback_days=320)
    hits = detect_golden_cross(close, vol, short=50, long=200, within_days=3, min_price=100, vol_ratio=1.0)
    notify(hits, top_n=15)

if __name__ == "__main__":
    main()
